// Future<String?> _charge() async => charge = _localStorage['charging_mos_switch'];
// Future<String?> _discharge() async => discharge = _localStorage['discharge_mos_switch'];
// Future<String?> _balance() async => balance = _localStorage['active_equalization_switch'];
// Future<String?> _bat_vol() async => bat_vol = _localStorage['bat_vol'];
// Future<String?> _bat_cap() async => bat_cap = _localStorage['bat_cap'];
// Future<String?> _bat_capacity() async => bat_capacity = _localStorage['bat_capacity'];
// Future<String?> _bat_temp() async => bat_temp = _localStorage['bat_temp'];
// Future<String?> _bat_percent() async => bat_percent = _localStorage['bat_percent'];
// Future<String?> _bat_cycles() async => bat_cycles = _localStorage['bat_cycles'];
// Future<String?> _box_temp() async => box_temp = _localStorage['box_temp'];
// Future<String?> _logger_status() async => logger_status = _localStorage['logger_status'];
// Future<String?> _tube_temp() async => tube_temp = _localStorage['tube_temp'];
// Future<String?> _bat_current() async => bat_current = _localStorage['bat_current'];
// Future<String?> _cell_diff() async => cell_diff = _localStorage['cell_diff'];
// Future<String?> _ave_cell() async => ave_cell = _localStorage['ave_cell'];
// // Stting data;
//
// Future<String?> _cellcount() async => _cellcount = _localStorage['strings_settings'];
// Future<String?> _batterycapacity() async => _batterycapacity = _localStorage['battery_capacity_settings'];
// Future<String?> _calibratingVolt() async => _calibratingVolt = _localStorage['bat_vol'];
// Future<String?> _calibratingCurr() async => _calibratingCurr = _localStorage['bat_current'];
// Future<String?> _cellOVP() async => _cellOVP = _localStorage['single_overvoltage'];
// Future<String?> _cellOVPR() async => _cellOVPR = _localStorage['monomer_overvoltage_recovery'];
// Future<String?> _cellUVPR() async => _cellUVPR = _localStorage['discharge_overcurrent_protection_value'];
// Future<String?> _cellUVP() async => _cellUVP = _localStorage['differential_voltage_protection_value'];
// Future<String?> _continuedChargeCurr() async => _continuedChargeCurr = _localStorage['equalizing_opening_differential'];
// Future<String?> _continuedDischargeCurr() async => _continuedDischargeCurr = _localStorage['charging_overcurrent_delay'];
// Future<String?> _dischargeOCPdelay() async => _dischargeOCPdelay = _localStorage['equalizing_starting_voltage'];
// Future<String?> _chargeOTP() async => _chargeOTP = _localStorage['high_temp_protect_bat_charge'];
// Future<String?> _dischargeOTP() async => _dischargeOTP = _localStorage['high_temp_protect_bat_discharge'];
// Future<String?> _chargeUTP() async => _chargeUTP = _localStorage['charge_cryo_protect'];
// Future<String?> _chargeUTPR() async => _chargeUTPR = _localStorage['recover_val_charge_cryoprotect'];
// Future<String?> _startBalanceVolt() async => _startBalanceVolt = _localStorage['tube_temp_protection'];
